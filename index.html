<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <title>Wasapok</title>
  <link rel="icon" type="image/x-icon" href="DiamondIcon.png">
  <style>
    @font-face {
      font-family: 'Sprintura';
      src: url('./Sprintura.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }
    html,body{height:100dvh;width:100vw;}
    body{
      margin:0;
      background:#000;
      overflow:hidden;
      touch-action:none;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;
      cursor: url('./diamondCur'), auto;
    }
    canvas{display:block;width:100vw!important;height:100dvh!important}
    .panel{position:fixed;top:12px;left:12px;z-index:9999;width:min(94vw,460px);max-height:calc(100dvh - 24px);overflow:auto;border-radius:14px;background:#0b1020e0;border:1px solid #88a7ff2a;color:#eaf0ff;box-shadow:0 8px 28px #000a;font-size:12px;display:none}
    .tabs{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;padding:8px;background:#0f1a38a6;border-bottom:1px solid #5c75b42a;position:sticky;top:0}
    .tab-btn{padding:8px 10px;border-radius:10px;border:1px solid #6aa2ff33;background:#0e1736;color:#d9e6ff;cursor:pointer}
    .tab-btn.active{background:#1a2a62;border-color:#89a6ff66}
    .tabpages{padding:10px}.tabpage{display:none}.tabpage.active{display:block}
    h3{margin:4px 0 10px;font-size:13px;color:#cfe0ff}
    .row{display:grid;grid-template-columns:1fr 60px;gap:8px;align-items:center;margin:6px 0}
    .row input[type="range"]{width:100%}
    .row input[type="number"]{width:60px;background:#0d1a3a;color:#eaf0ff;border:1px solid #446;border-radius:6px;padding:4px 6px;font-size:12px}
    .two{display:flex;gap:8px;margin-top:8px}.two>button{flex:1 1 0;padding:8px 10px;border-radius:10px;border:1px solid #6aa2ff33;background:#0e1736;color:#d9e6ff;cursor:pointer}
    #toggleControls,#enableMotion{position:fixed;right:16px;z-index:10000;padding:10px 14px;border-radius:12px;border:1px solid #6aa2ff33;background:#0b1020;color:#cfe0ff;font:600 12px/1.2 system-ui;letter-spacing:.05em;box-shadow:0 6px 20px #0007}
    #toggleControls{bottom:16px}
    #enableMotion{
      bottom:66px;display:none;
      pointer-events:auto;
      touch-action:manipulation;
    }
    #enableMotion {
      position:fixed;
      right:16px;
      z-index:10000;
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #669b80df;
      background:#0c1f31;
      color:#b4ffd6;
      font:600 12px/1.2 system-ui;
      font-family: 'Sprintura';
      letter-spacing:.05em;
      box-shadow:0 6px 20px #0007
    }

    #fun{ color: #f5f246; }
  </style>
</head>
<body>
  <div class="panel" id="panel">
    <div class="tabs" id="tabs">
      <button class="tab-btn active" data-tab="vaseTab">vase</button>
      <button class="tab-btn" data-tab="roomTab">room</button>
      <button class="tab-btn" data-tab="lightsTab">lights</button>
      <button class="tab-btn" data-tab="waterTab">water</button>
      <button class="tab-btn" data-tab="vaseFxTab">glass</button>
      <button class="tab-btn" data-tab="headerTab">header</button>
      <button class="tab-btn" data-tab="badgesTab">badges</button>
      <button class="tab-btn" data-tab="postTab">post</button>
    </div>
    <div class="tabpages">
      <div class="tabpage active" id="vaseTab">
        <h3>Vase</h3>
        <div class="row"><label>Scale ×</label><input id="vaseNum" type="number" step="0.01"><input id="vase" type="range" min="0.2" max="4.0" step="0.01"></div>
        <div class="row"><label>Tallness Y</label><input id="vaseYNum" type="number" step="0.01"><input id="vaseY" type="range" min="0.5" max="3.0" step="0.01"></div>
        <div class="row"><label>Pos Z</label><input id="vaseZNum" type="number" step="0.1"><input id="vaseZ" type="range" min="-40" max="2" step="0.1"></div>
        <div class="row"><label>Pos Y</label><input id="vaseYPosNum" type="number" step="0.1"><input id="vaseYPos" type="range" min="-10" max="8" step="0.1"></div>
        <h3>Spin</h3>
        <div class="row"><label>Damping</label><input id="dampNum" type="number" step="0.001"><input id="damp" type="range" min="0.90" max="0.999" step="0.001"></div>
        <div class="row"><label>Min Spin</label><input id="minNum" type="number" step="0.01"><input id="min" type="range" min="0.0" max="0.6" step="0.01"></div>
        <div class="row"><label>Swipe Impulse</label><input id="impNum" type="number" step="0.0001"><input id="imp" type="range" min="0.0005" max="0.05" step="0.0001"></div>
        <div class="two"><button id="printControlsBtn">Print controls</button><button id="copyControlsBtn">Copy controls</button></div>
      </div>

      <div class="tabpage" id="roomTab">
        <h3>Room</h3>
        <div class="row"><label>Depth</label><input id="dNum" type="number" step="0.1"><input id="d" type="range" min="3" max="40" step="0.1"></div>
        <div class="row"><label>Room Z</label><input id="zNum" type="number" step="0.1"><input id="z" type="range" min="-40" max="0" step="0.1"></div>
        <div class="row"><label>Image Zoom</label><input id="zoomNum" type="number" step="0.01"><input id="zoom" type="range" min="0.5" max="3.2" step="0.01"></div>
        <div class="row"><label>Border Opacity</label><input id="edgeNum" type="number" step="0.01"><input id="edge" type="range" min="0" max="1" step="0.01"></div>
      </div>

      <div class="tabpage" id="lightsTab">
        <h3>Lights</h3>
        <div class="row"><label>Exposure</label><input id="expNum" type="number" step="0.01"><input id="exp" type="range" min="0.2" max="3.5" step="0.01"></div>
        <div class="row"><label>Ambient</label><input id="ambNum" type="number" step="0.01"><input id="amb" type="range" min="0" max="3.5" step="0.01"></div>
        <div class="row"><label>Hemisphere</label><input id="hemNum" type="number" step="0.01"><input id="hem" type="range" min="0" max="3.5" step="0.01"></div>
        <div class="row"><label>Rim</label><input id="rimNum" type="number" step="0.01"><input id="rim" type="range" min="0" max="5" step="0.01"></div>
        <div class="row"><label>Key</label><input id="keyNum" type="number" step="0.01"><input id="key" type="range" min="0" max="5" step="0.01"></div>
        <h3>Vase Light</h3>
        <div class="row"><label>Intensity</label><input id="vlINum" type="number" step="0.01"><input id="vlI" type="range" min="0" max="30" step="0.01"></div>
        <div class="row"><label>Distance</label><input id="vlDNum" type="number" step="0.1"><input id="vlD" type="range" min="0.1" max="40" step="0.1"></div>
        <div class="row"><label>Decay</label><input id="vlDecNum" type="number" step="0.1"><input id="vlDec" type="range" min="0" max="3" step="0.1"></div>
        <div class="row"><label>Y Position</label><input id="vlYNum" type="number" step="0.01"><input id="vlY" type="range" min="-4" max="4" step="0.01"></div>
      </div>

      <div class="tabpage" id="waterTab">
        <h3>Water</h3>
        <div class="row"><label>Amplitude</label><input id="wAmpNum" type="number" step="0.01"><input id="wAmp" type="range" min="0" max="3.0" step="0.01"></div>
        <div class="row"><label>Frequency</label><input id="wFreqNum" type="number" step="0.1"><input id="wFreq" type="range" min="1" max="60" step="0.1"></div>
        <div class="row"><label>Wave Speed</label><input id="wSpeedNum" type="number" step="0.01"><input id="wSpeed" type="range" min="0" max="8" step="0.01"></div>
        <div class="row"><label>Falloff</label><input id="wFallNum" type="number" step="0.01"><input id="wFall" type="range" min="0.1" max="4.0" step="0.01"></div>
        <div class="row"><label>Alpha</label><input id="wAlphaNum" type="number" step="0.01"><input id="wAlpha" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Radius</label><input id="wRadNum" type="number" step="0.1"><input id="wRad" type="range" min="0.5" max="8.0" step="0.1"></div>
        <div class="row"><label>Pixelation</label><input id="wPixNum" type="number" step="1"><input id="wPix" type="range" min="1" max="48" step="1"></div>
        <div class="row"><label>Y Offset</label><input id="wYNum" type="number" step="0.01"><input id="wY" type="range" min="-3" max="3" step="0.01"></div>
      </div>

      <div class="tabpage" id="vaseFxTab">
        <h3>Glass</h3>
        <div class="row"><label>Transmission</label><input id="glassTransNum" type="number" step="0.01"><input id="glassTrans" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Thickness</label><input id="glassThickNum" type="number" step="0.01"><input id="glassThick" type="range" min="0.1" max="4" step="0.01"></div>
        <div class="row"><label>IOR</label><input id="glassIorNum" type="number" step="0.01"><input id="glassIor" type="range" min="1.0" max="2.5" step="0.01"></div>
        <div class="row"><label>Roughness</label><input id="glassRoughNum" type="number" step="0.01"><input id="glassRough" type="range" min="0.0" max="1.0" step="0.01"></div>
        <div class="row"><label>Clearcoat</label><input id="glassCCNum" type="number" step="0.01"><input id="glassCC" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>CC Roughness</label><input id="glassCCRNum" type="number" step="0.01"><input id="glassCCR" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Env Intensity</label><input id="glassEnvNum" type="number" step="0.01"><input id="glassEnv" type="range" min="0" max="4" step="0.01"></div>
        <div class="row"><label>Metalness</label><input id="glassMetalNum" type="number" step="0.01"><input id="glassMetal" type="range" min="0" max="1" step="0.01"></div>
      </div>

      <div class="tabpage" id="headerTab">
        <h3>Header Text (opacity auto)</h3>
        <div class="row"><label>Size ×</label><input id="hdrSizeNum" type="number" step="0.01" min="0.2" max="3"><input id="hdrSize" type="range" min="0.2" max="3" step="0.01"></div>
        <div class="row"><label>Pos X</label><input id="hdrXNum" type="number" step="0.1"><input id="hdrX" type="range" min="-40" max="40" step="0.1"></div>
        <div class="row"><label>Pos Y</label><input id="hdrYNum" type="number" step="0.1"><input id="hdrY" type="range" min="-20" max="20" step="0.1"></div>
        <div class="row"><label>Pos Z</label><input id="hdrZNum" type="number" step="0.1"><input id="hdrZ" type="range" min="-40" max="40" step="0.1"></div>
        <h3>Header Material</h3>
        <div class="row"><label>Metalness</label><input id="hdrMetalNum" type="number" step="0.01"><input id="hdrMetal" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Roughness</label><input id="hdrRoughNum" type="number" step="0.01"><input id="hdrRough" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Clearcoat</label><input id="hdrCCNum" type="number" step="0.01"><input id="hdrCC" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>CC Roughness</label><input id="hdrCCRNum" type="number" step="0.01"><input id="hdrCCR" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Env Intensity</label><input id="hdrEnvNum" type="number" step="0.01"><input id="hdrEnv" type="range" min="0" max="4" step="0.01"></div>
        <div class="row"><label>Transmission</label><input id="hdrTransNum" type="number" step="0.01"><input id="hdrTrans" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Depth/Thickness ×</label><input id="hdrThickNum" type="number" step="0.01"><input id="hdrThick" type="range" min="0.2" max="3" step="0.01"></div>
        <div class="row"><label>Emissive Intensity</label><input id="hdrEmissNum" type="number" step="0.01"><input id="hdrEmiss" type="range" min="0" max="3" step="0.01"></div>
      </div>

      <div class="tabpage" id="badgesTab">
        <h3>Badges</h3>
        <div class="row"><label>Badge Size ×</label><input id="bdgSizeNum" type="number" step="0.01"><input id="bdgSize" type="range" min="0.3" max="3" step="0.01"></div>
        <div class="row"><label>X Offset ×</label><input id="bdgXOffNum" type="number" step="0.01"><input id="bdgXOff" type="range" min="0" max="2" step="0.01"></div>
        <div class="row"><label>Y Position</label><input id="bdgYPosNum" type="number" step="0.1"><input id="bdgYPos" type="range" min="-20" max="20" step="0.1"></div>
        <div class="row"><label>Z Offset</label><input id="bdgZOffNum" type="number" step="0.1"><input id="bdgZOff" type="range" min="-10" max="10" step="0.1"></div>
      </div>

      <div class="tabpage" id="postTab">
        <h3>Post</h3>
        <div class="row"><label>Pixel Size</label><input id="pixNum" type="number" step="1"><input id="pix" type="range" min="1" max="24" step="1"></div>
        <div class="row"><label>Dither Strength</label><input id="dithNum" type="number" step="0.01"><input id="dith" type="range" min="0" max="1" step="0.01"></div>
      </div>
    </div>
  </div>

  <!-- <button id="toggleControls">Controls (H)</button> -->
  <!-- <button id="enableMotion">Enable Fun</button> -->
  <div id="enableMotion"> <span id="fun">V</span>.meste <span id="fun">F</span>orever</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
    import { Font } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    /* ---------- utility ---------- */
    const vw = ()=> (window.visualViewport?.width  || window.innerWidth);
    const vh = ()=> (window.visualViewport?.height || window.innerHeight);
    const isPortrait = ()=> vh() >= vw();
    const isTouch = ()=> ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    const isPhone = ()=> isTouch() && (Math.min(vw(), vh()) < 820);

    const params = new URLSearchParams(location.search);
    function getStoredPreset(){ try{ return localStorage.getItem('room_preset_override') || ''; }catch(_){ return ''; } }
    function setStoredPreset(v){ try{ localStorage.setItem('room_preset_override', v); }catch(_){ } }
    const urlPreset = (params.get('preset')||'').toLowerCase();
    if (urlPreset === 'phone' || urlPreset === 'desktop') setStoredPreset(urlPreset);
    const presetChoice = getStoredPreset() || (isPhone() ? 'phone' : 'desktop');

    /* ---------- presets ---------- */
    const desktop = {
      room:{
        width:18.766829922078774,
        height:10.18770767198562,
        depth:14.5,
        positionZ:-10.8,
        imageZoom:0.96,
        borderOpacity:0,
        wallEmissive:0.38,
        wallDispAmp:0.006,
        wallDispSpeed:2.39
      },
      lights:{
        exposure:0.86,
        ambient:1.85,
        hemisphere:2.6,
        rim:1.87,
        key:1.68,
        vaseLight:{
          intensity:4.82,
          distance:10.6,
          decay:1.1,
          y:0.32
        }
      },
      vase:{
        userScaleMult:3.11,
        userTallY:1.06,
        z:-10.7,
        y:-4.8
      },
      spin:{
        damping:0.997,
        minSpin:0.2,
        swipeImpulse:0.14
      },
      post:{
        pixelSize:5,
        ditherStrength:0.41
      },
      water:{
        amp:0,
        freq:38.3,
        speed:0.53,
        falloff:1.05,
        alpha:0.35,
        radius:2.5,
        pixel:6,
        yOffset:-0.05,
        tint:[0.45,0.75,1]
      },
      glass:{
        transmission:1,
        thickness:0.76,
        ior:2.5,
        roughness:0,
        clearcoat:0.52,
        ccRough:0.27,
        envIntensity:1.33,
        metalness:0.94,
        color:[1,1,1],
        attnColor:[0.66,0.79,1]
      },
      _internal:{
        WATER_RADIUS_FACTOR:0.74,
        TILT_MARGIN:1.1247358823385865
      },
      header:{
        opacity:0.99,
        sizeMul:0.63,
        x:0,
        y:2.5,
        z:-3.7,
        locked:true,
        metalness:1,
        roughness:0.04,
        clearcoat:1,
        clearcoatRoughness:0,
        envIntensity:1.27,
        transmission:0,
        thickness:2.31,
        emissiveIntensity:0.28
      },
      badges:{
        sizeMul:2.44,
        offsetXMul:1.15,
        yPos:4.4,
        zOffset:1.9,
        activated:true
      },
      _preset:'desktop'
    };

    const phone = {
      room:{
        width:3.2466138193122998,
        height:7.026005291024567,
        depth:6.6,
        positionZ:-10.4,
        imageZoom:0.96,
        borderOpacity:0,
        wallEmissive:0.32,
        wallDispAmp:0.011,
        wallDispSpeed:2.19
      },
      lights:{
        exposure:1.49,
        ambient:0.82,
        hemisphere:3.48,
        rim:3.76,
        key:1.47,
        vaseLight:{
          intensity:7.17,
          distance:2.9,
          decay:2.5,
          y:0.77
        }
      },
      vase:{
        userScaleMult:1.47,
        userTallY:1.55,
        z:-9.3,
        y:-3
      },
      spin:{
        damping:0.997,
        minSpin:0.2,
        swipeImpulse:0.14
      },
      post:{
        pixelSize:4,
        ditherStrength:0.52
      },
      water:{
        amp:0,
        freq:26.5,
        speed:0.82,
        falloff:0.9,
        alpha:0.44,
        radius:2.9,
        pixel:24,
        yOffset:-0.05,
        tint:[0.45,0.75,1]
      },
      glass:{
        transmission:0.91,
        thickness:2.22,
        ior:2.12,
        roughness:0,
        clearcoat:0.81,
        ccRough:0.67,
        envIntensity:1.58,
        metalness:1,
        color:[1,1,1],
        attnColor:[0.66,0.79,1]
      },
      _internal:{
        WATER_RADIUS_FACTOR:0.74,
        TILT_MARGIN:1.1247358823385865
      },
      header:{
        opacity:0.99,
        sizeMul:2.6,
        x:0,
        y:9.4,
        z:-29.6,
        locked:true,
        metalness:0.98,
        roughness:0,
        clearcoat:0.93,
        clearcoatRoughness:0.59,
        envIntensity:1.79,
        transmission:0.67,
        thickness:2.58,
        emissiveIntensity:1
      },
      badges:{
        sizeMul:1.6,
        offsetXMul:0.6,
        yPos:4.7,
        zOffset:-1,
        activated:true
      },
      _preset:'phone'
    };

    const CONFIG = structuredClone(presetChoice==='phone' ? phone : desktop);

    /* ============================================================
       ALBUM SWITCH: spin right => Album A, spin left => Album B
       ============================================================ */
    const ALBUMS = {
      A: {
        // Original album (spin right / angVel >= 0)
        titleDesktop: 'Biome .•.•.•:::Plain.',
        titlePhone:   'Biome \n.•.•.•:::Plain.',  // IMPORTANT: real newline on mobile
        wallImage:    '/reilly-album-cvr.jpeg',
        audioUrl:     './soundtrackComp.mp3',
        spotifyUrl:   'https://open.spotify.com/album/56nqfRzDXsfFjm5Pl1wKhf?si=4MAm0FpYSB2DodAE9SYkmQ',
        appleUrl:     'https://music.apple.com/us/album/biome-plain-ep/1858512958',
        zoomTerminalValues: [0.66, 0.48, 0.88, 0.96, 3.2]
      },
      B: {
        // New album (spin left / angVel < 0)
        titleDesktop: 'Palm Tree Syrup',
        titlePhone:   'Palm Tree\nSyrup',          // IMPORTANT: real newline on mobile
        wallImage:    '/palm_tree.jpeg',
        audioUrl:     './soundtrackSyrup.mp3',
        spotifyUrl:   'https://open.spotify.com/album/7w2jzK97H1Uwois7kgHxdN?si=pCyBuTLKQFKpFT_toUBHtA',
        appleUrl:     'https://music.apple.com/us/album/palm-tree-syrup-ep/1869613519',
        // NEW: different zoom terminals for Album B
        zoomTerminalValues: [1.38, 0.66, 4.0, 0.87]
      }
    };

    function albumKeyFromAngVel(v){
      return (v < 0) ? 'B' : 'A';
    }

    let currentAlbumKey = 'A'; // default on load

    function getHeaderTextForAlbum(key){
      return (presetChoice === 'phone') ? ALBUMS[key].titlePhone : ALBUMS[key].titleDesktop;
    }

    /* ---------- zoom state (UPDATED: per-album terminals) ---------- */
    let zoomBase = CONFIG.room.imageZoom;
    let zoomCurrent = CONFIG.room.imageZoom;

    function getZoomTerminals(){
      return ALBUMS[currentAlbumKey]?.zoomTerminalValues || [0.66, 0.48, 0.88, 0.96, 3.2];
    }

    /* ---------- renderer, scene, camera ---------- */
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true, powerPreference:'high-performance'});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, isPhone()?1.5:1.8));
    renderer.setSize(vw(), vh(), false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = CONFIG.lights.exposure;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0d1220, 18, 40);

    const camera = new THREE.PerspectiveCamera(55, vw()/vh(), 0.1, 100);
    camera.position.set(0,0,7.5);

    /* ---------- wall (preload two textures + swap map) ---------- */
    const tLoader = new THREE.TextureLoader(); tLoader.setCrossOrigin("anonymous");

    function applyTextureZoom(texture, z){
      if(!texture) return;
      const r=1/Math.max(z,0.0001);
      texture.center.set(0.5,0.5);
      texture.repeat.set(r,r);
      texture.offset.set((1-r)*0.5,(1-r)*0.5);
      texture.needsUpdate=true;
    }

    const wallTextures = {};
    function loadWallTexture(key, url){
      const tex = tLoader.load(url, t=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
        t.anisotropy = renderer.capabilities.getMaxAnisotropy();
        applyTextureZoom(t, CONFIG.room.imageZoom);
        if(currentAlbumKey === key && wallMat){
          wallMat.map = t;
          wallMat.needsUpdate = true;
        }
      });
      wallTextures[key] = tex;
      return tex;
    }

    const wallTexA = loadWallTexture('A', ALBUMS.A.wallImage);
    const wallTexB = loadWallTexture('B', ALBUMS.B.wallImage);
    let currentWallTex = wallTexA;

    const wallMat = new THREE.MeshStandardMaterial({
      map: currentWallTex, side: THREE.BackSide,
      roughness: 0.8, metalness: 0.0,
      emissive: new THREE.Color(0x2a365c),
      emissiveIntensity: CONFIG.room.wallEmissive,
      envMapIntensity: 0.18
    });

    let wallShader=null;
    wallMat.onBeforeCompile = (s)=>{
      s.fragmentShader = s.fragmentShader
        .replace('#include <common>', `#include <common>
          uniform float uTime; uniform float uDispAmp; uniform float uDispSpeed;`)
        .replace('#include <map_fragment>', `#ifdef USE_MAP
          vec2 uv2 = vMapUv;
          float g=120.0; vec2 grid=floor(uv2*g)/g;
          float t=uTime*uDispSpeed;
          vec2 warp=vec2( sin(grid.y*40.0+t*2.2), cos(grid.x*40.0-t*1.7) )*uDispAmp;
          vec4 sampledDiffuseColor = texture2D(map, uv2+warp);
          diffuseColor *= sampledDiffuseColor;
        #endif`);
      s.uniforms.uTime      = { value: 0 };
      s.uniforms.uDispAmp   = { value: CONFIG.room.wallDispAmp };
      s.uniforms.uDispSpeed = { value: CONFIG.room.wallDispSpeed };
      wallShader = s;
    };

    function applyZoom(v){
      zoomCurrent = v;
      CONFIG.room.imageZoom = v;
      applyTextureZoom(currentWallTex, v);
      const slider = document.getElementById('zoom');
      const num = document.getElementById('zoomNum');
      if(slider) slider.value = v;
      if(num) num.value = v;
    }

    function triggerZoomJump(){
      const vals = getZoomTerminals();
      const eps = 1e-3;
      let candidates = vals.filter(v => Math.abs(v - zoomCurrent) > eps);
      if(candidates.length === 0) candidates = vals.slice();
      const target = candidates[Math.floor(Math.random()*candidates.length)];
      zoomBase = target;
      applyZoom(target);
    }

    function setAlbum(key, {force=false} = {}){
      if(!force && key === currentAlbumKey) return;
      currentAlbumKey = key;

      const tex = wallTextures[key];
      if(tex){
        currentWallTex = tex;
        wallMat.map = tex;
        wallMat.needsUpdate = true;
        applyTextureZoom(currentWallTex, zoomCurrent);
      }

      if(headerFont) rebuildHeaderGeometry();
      switchAudioTo(key).catch(()=>{});
    }

    /* ---------- room box ---------- */
    let ROOM_W=CONFIG.room.width, ROOM_H=CONFIG.room.height, ROOM_D=CONFIG.room.depth;
    function buildRoomGeometry(w,h,d){
      const geo = new THREE.BoxGeometry(w,h,d,1,1,1);
      const uv = geo.getAttribute('uv'); const A=uv.array;
      const tileW=1/4,tileH=1/3;
      const faces=[
        {u0:0.5,v0:1/3},{u0:0.0,v0:1/3},{u0:0.25,v0:2/3},
        {u0:0.25,v0:0.0},{u0:0.25,v0:1/3},{u0:0.75,v0:1/3}
      ];
      const put=(off,u0,v0,u1,v1)=>{ const uvs=[u0,v0,u1,v0,u0,v1, u1,v0,u1,v1,u0,v1]; for(let i=0;i<12;i++)A[off+i]=uvs[i];};
      for(let f=0;f<6;f++){ const r=faces[f]; put(f*12, r.u0,r.v0, r.u0+tileW, r.v0+tileH); }
      uv.needsUpdate=true; return geo;
    }
    const roomGeo = buildRoomGeometry(ROOM_W,ROOM_H,ROOM_D);
    const room = new THREE.Mesh(roomGeo, wallMat); room.position.set(0,0,CONFIG.room.positionZ); scene.add(room);
    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(roomGeo), new THREE.LineBasicMaterial({color:0xF0F6FF,transparent:true,opacity:CONFIG.room.borderOpacity}));
    edges.position.copy(room.position); scene.add(edges);

    const BASE_VFOV_DEG = 55;
    let WATER_RADIUS_FACTOR = CONFIG._internal?.WATER_RADIUS_FACTOR ?? 0.74;
    let TILT_MARGIN = CONFIG._internal?.TILT_MARGIN ?? 1.1247358823385865;

    function computeTargetDistance(depth){ return THREE.MathUtils.clamp(depth*0.6, 6.0, 20.0); }
    function adjustRoomToViewport(){
      const aspect = vw()/vh();
      const openingZ = room.position.z + ROOM_D*0.5;
      const dTarget = computeTargetDistance(ROOM_D);
      camera.fov = BASE_VFOV_DEG;
      camera.aspect = aspect;
      camera.position.set(0,0, openingZ + dTarget);
      const halfH = Math.tan(THREE.MathUtils.degToRad(BASE_VFOV_DEG)*0.5)*dTarget;
      const targetH = 2*halfH*TILT_MARGIN; const targetW = targetH*aspect;
      ROOM_H = targetH; ROOM_W = targetW;
      const newGeo = buildRoomGeometry(ROOM_W,ROOM_H,ROOM_D);
      room.geometry.dispose(); room.geometry=newGeo;
      edges.geometry.dispose(); edges.geometry=new THREE.EdgesGeometry(newGeo);
      rebuildWaterCircle(); resizeWater();
      if(headerFont) rebuildHeaderGeometry();
      camera.near = 0.05; camera.far = 120; camera.updateProjectionMatrix();
    }

    /* ---------- lights ---------- */
    const amb = new THREE.AmbientLight(0xffffff, CONFIG.lights.ambient); scene.add(amb);
    const hemi = new THREE.HemisphereLight(0x9fbfff, 0x202a44, CONFIG.lights.hemisphere); scene.add(hemi);
    const rim = new THREE.DirectionalLight(0xeef3ff, CONFIG.lights.rim); rim.position.set(-1.4,2.2,1.6); scene.add(rim);
    const key = new THREE.PointLight(0xffffff, CONFIG.lights.key, 18, 2.0);
    key.position.set(1.5, -ROOM_H*0.1, room.position.z + ROOM_D*0.05); scene.add(key);

    /* ---------- dynamic envmap ---------- */
    const cubeRT = new THREE.WebGLCubeRenderTarget(256,{generateMipmaps:true,minFilter:THREE.LinearMipmapLinearFilter,magFilter:THREE.LinearFilter});
    cubeRT.texture.colorSpace = THREE.SRGBColorSpace;
    const cubeCam = new THREE.CubeCamera(0.1, 100, cubeRT); scene.add(cubeCam);

    /* ---------- vase ---------- */
    const vaseGroup = new THREE.Group();
    scene.add(vaseGroup);
    const vaseLight = new THREE.PointLight(0xaad4ff, CONFIG.lights.vaseLight.intensity, CONFIG.lights.vaseLight.distance, CONFIG.lights.vaseLight.decay);
    vaseLight.position.set(0, CONFIG.lights.vaseLight.y, 0); vaseGroup.add(vaseLight);

    let vase=null, vaseReady=false, vaseBaseScale=1, userScaleMult=CONFIG.vase.userScaleMult, userTallY=CONFIG.vase.userTallY;
    const glassMaterials=[];
    new GLTFLoader().load('./vaseNew.glb', g=>{
      vase = g.scene;
      const baseGlass = {
        color:new THREE.Color().setRGB(...CONFIG.glass.color),
        metalness:CONFIG.glass.metalness, roughness:CONFIG.glass.roughness,
        transmission:CONFIG.glass.transmission, thickness:CONFIG.glass.thickness, ior:CONFIG.glass.ior,
        clearcoat:CONFIG.glass.clearcoat, clearcoatRoughness:CONFIG.glass.ccRough,
        attenuationColor:new THREE.Color().setRGB(...CONFIG.glass.attnColor), attenuationDistance:2.0,
        envMap:cubeRT.texture, envMapIntensity:CONFIG.glass.envIntensity
      };
      vase.traverse(n=>{
        if(n.isMesh){
          const m=new THREE.MeshPhysicalMaterial(baseGlass);
          m.emissive.setRGB(0.02,0.03,0.06); m.emissiveIntensity=0.08;
          glassMaterials.push(m); n.material=m;
        }
      });
      vaseBaseScale = autoScaleToRoom(vase); applyVaseScale();
      vaseGroup.add(vase); placeOnFloor(vaseGroup);
      vaseGroup.position.set(0, CONFIG.vase.y, CONFIG.vase.z);
      vaseReady=true; syncVasePositionInputs();
    });
    function roomFloorY(){return -ROOM_H*0.5+0.02}
    function placeOnFloor(obj){ obj.updateMatrixWorld(true); const bbox=new THREE.Box3().setFromObject(obj); obj.position.y += (roomFloorY() - bbox.min.y); }
    function autoScaleToRoom(obj){ const bbox=new THREE.Box3().setFromObject(obj); const s=new THREE.Vector3(); bbox.getSize(s); const maxTarget=Math.min(ROOM_H*0.38, ROOM_W*0.38); return maxTarget/Math.max(s.x,s.y,s.z); }
    function applyVaseScale(){ if(!vase)return; const portraitBoost=(isPortrait() && presetChoice==='phone')?1.7:1.0; const s=vaseBaseScale*portraitBoost*userScaleMult; vase.scale.set(s,s*userTallY,s); }

    /* ---------- header (3D text) ---------- */
    const FONT_URL='./Sprintura.otf';
    const headerGroup=new THREE.Group();
    scene.add(headerGroup);
    let headerMesh=null, headerMat=null, headerFont=null;
    const headerCfg={
      sizeMul: CONFIG.header?.sizeMul ?? 1.0,
      x: CONFIG.header?.x ?? 0, y: CONFIG.header?.y ?? 2.0, z: CONFIG.header?.z ?? 6.0,
      metalness: CONFIG.header?.metalness ?? 1.0,
      roughness: CONFIG.header?.roughness ?? 0.18,
      clearcoat: CONFIG.header?.clearcoat ?? 1.0,
      clearcoatRoughness: CONFIG.header?.clearcoatRoughness ?? 0.35,
      envIntensity: CONFIG.header?.envIntensity ?? 1.6,
      transmission: CONFIG.header?.transmission ?? 0.32,
      thickness: CONFIG.header?.thickness ?? 1.0,
      emissiveIntensity: CONFIG.header?.emissiveIntensity ?? 0.32
    };
    let headerOpacityLocked=false; const HEADER_OPACITY_MAX=0.99;

    function headerBaseSize(){ return Math.min(ROOM_W,ROOM_H)*0.145; }
    function headerBaseHeight(){ return Math.min(ROOM_W,ROOM_H)*0.035; }
    function buildHeaderMaterial(){
      headerMat=new THREE.MeshPhysicalMaterial({
        color:0xCFE0FF,
        metalness:headerCfg.metalness,
        roughness:headerCfg.roughness,
        clearcoat:headerCfg.clearcoat,
        clearcoatRoughness:headerCfg.clearcoatRoughness,
        envMap:cubeRT.texture,
        envMapIntensity:headerCfg.envIntensity,
        transmission:headerCfg.transmission,
        thickness:headerCfg.thickness,
        ior:1.45,
        side:THREE.FrontSide,
        transparent:true,
        opacity:0.0,
        depthTest:false,
        depthWrite:false,
        emissive:new THREE.Color(0x6f8bbf),
        emissiveIntensity:headerCfg.emissiveIntensity
      });
    }
    function applyHeaderTransform(){ headerGroup.position.set(headerCfg.x, headerCfg.y, headerCfg.z); }
    function rebuildHeaderGeometry(){
      if(!headerFont) return;
      const HEADER_TEXT = getHeaderTextForAlbum(currentAlbumKey);
      if(headerMesh){ headerGroup.remove(headerMesh); headerMesh.geometry.dispose(); }
      const geo=new TextGeometry(HEADER_TEXT,{
        font:headerFont,
        size:headerBaseSize()*headerCfg.sizeMul,
        height:headerBaseHeight()*headerCfg.sizeMul*headerCfg.thickness,
        curveSegments:10,
        bevelEnabled:true,
        bevelThickness:Math.min(ROOM_W,ROOM_H)*0.003*headerCfg.sizeMul*headerCfg.thickness,
        bevelSize:Math.min(ROOM_W,ROOM_H)*0.002*headerCfg.sizeMul*headerCfg.thickness,
        bevelSegments:4
      });
      geo.computeBoundingBox(); geo.center();
      if(!headerMat) buildHeaderMaterial();
      headerMesh=new THREE.Mesh(geo, headerMat);
      headerMesh.renderOrder=999;
      headerGroup.add(headerMesh);
      applyHeaderTransform();
    }

    new TTFLoader().load(FONT_URL, json=>{
      headerFont=new Font(json);
      buildHeaderMaterial();
      rebuildHeaderGeometry();
    });

    /* ---------- spin physics + timed full-speed hold ---------- */
    let angVel=0, tilt=0, wobble=0;
    let DAMPING=CONFIG.spin.damping, MIN_SPIN=CONFIG.spin.minSpin, IMPULSE=CONFIG.spin.swipeImpulse;
    const FULL_SPIN = (presetChoice==='phone')?9.0:8.0;
    const HOLD_SECS = 10.0;

    let holdActive = false;
    let holdEndTime = 0;
    let holdDir = 0;
    let requestExtendHold = false;

    let dragging=false, lastX=0, lastT=0;

    function getX(e){
      if(e.touches?.length) return e.touches[0].clientX;
      if(e.changedTouches?.length) return e.changedTouches[0].clientX;
      return e.clientX||0;
    }

    function onDown(e){
      dragging=true;
      lastX=getX(e);
      lastT=performance.now();
      maybeStartAudio();
    }

    function onMove(e){
      if(!dragging) return;
      const now=performance.now();
      const dx=getX(e)-lastX;
      const dt=Math.max(1, now-lastT);
      const dv=(dx/dt)*IMPULSE;
      const prevVel = angVel;

      angVel += dv;

      // album switches by direction (side)
      setAlbum(albumKeyFromAngVel(angVel));

      if(prevVel !== 0 && dv*prevVel < 0){
        holdActive=false;
        holdEndTime=0;
      }

      if(dv*prevVel > 0 && Math.abs(angVel) >= FULL_SPIN*0.98){
        requestExtendHold = true;
      }

      lastX=getX(e);
      lastT=now;
    }

    function onUp(){ dragging=false; }

    window.addEventListener('mousedown',onDown,{passive:true});
    window.addEventListener('mousemove',onMove,{passive:true});
    window.addEventListener('mouseup',onUp,{passive:true});
    window.addEventListener('touchstart',onDown,{passive:true});
    window.addEventListener('touchmove',onMove,{passive:true});
    window.addEventListener('touchend',onUp,{passive:true});

    function updateVase(dt, time){
      if(!vaseReady) return;

      if(requestExtendHold && Math.abs(angVel) >= FULL_SPIN*0.98){
        if(!holdActive){
          triggerZoomJump(); // uses per-album terminal set
        }
        holdActive = true;
        const s = Math.sign(angVel) || (holdDir || 1);
        holdDir = s;
        holdEndTime = time + HOLD_SECS;
      }
      requestExtendHold = false;

      if(holdActive && time >= holdEndTime){
        holdActive = false;
      }

      const sgn = (angVel>=0?1:-1)||1;

      if(holdActive){
        const dir = holdDir || sgn;
        const target = dir * FULL_SPIN;
        angVel += (target - angVel) * Math.min(1, dt*5.0);
      }else{
        angVel *= Math.pow(DAMPING, dt*60);
        if(Math.abs(angVel) < MIN_SPIN){
          angVel = (angVel>=0?MIN_SPIN:-MIN_SPIN);
        }
      }

      // keep album synced after inertia/hold
      setAlbum(albumKeyFromAngVel(angVel));

      const maxSpin = FULL_SPIN*100.0;
      if(Math.abs(angVel)>maxSpin) angVel=Math.sign(angVel)*maxSpin;

      const k = Math.min(1, Math.abs(angVel)/(FULL_SPIN*1.2));
      const targetTilt = THREE.MathUtils.degToRad(THREE.MathUtils.lerp(45,10,k));
      tilt += (targetTilt - tilt) * Math.min(1, dt*3.0);
      const wobA = THREE.MathUtils.lerp(0.11,0.03,k);
      const wobF = THREE.MathUtils.lerp(0.8,3.2,k);
      wobble += wobF*dt;

      vaseGroup.rotation.y += angVel*dt;
      vaseGroup.rotation.x = tilt + Math.sin(wobble)*wobA;
      vaseGroup.rotation.z = Math.cos(wobble*0.9)*(wobA*0.6);
    }

    /* ---------- input tilt ---------- */
    const enableMotionBtn=document.getElementById('enableMotion');
    let targetRX=0,targetRY=0, baseB=null,baseG=null, pointerMoveAttached=false;
    function onPointerMove(e){ const x=(e.clientX/vw())*2-1, y=(e.clientY/vh())*2-1; targetRY=x*0.085; targetRX=-y*0.085*0.6; }
    function onDeviceOrientation(e){ if(baseB===null) baseB=e.beta||0; if(baseG===null) baseG=e.gamma||0; const dB=(e.beta||0)-baseB, dG=(e.gamma||0)-baseG; targetRY=THREE.MathUtils.clamp(dG/45,-1,1)*0.085; targetRX=-THREE.MathUtils.clamp(dB/60,-1,1)*0.085*0.6; }
    function setupInput(){
      if(pointerMoveAttached){ window.removeEventListener('pointermove',onPointerMove); pointerMoveAttached=false; }
      window.removeEventListener('deviceorientation', onDeviceOrientation, true);
      enableMotionBtn.style.display='none';
      if(isPortrait() && presetChoice==='phone' && window.DeviceOrientationEvent){
        const needsPerm = typeof DeviceOrientationEvent.requestPermission === 'function';
        if (needsPerm){
          enableMotionBtn.style.display='block';
          enableMotionBtn.onclick=async()=>{
            try{
              const r=await DeviceOrientationEvent.requestPermission();
              if(r==='granted'){
                window.addEventListener('deviceorientation', onDeviceOrientation, true);
                enableMotionBtn.remove();
              }
            }catch(e){}
            maybeStartAudio(true);
          };
        }else{
          window.addEventListener('deviceorientation', onDeviceOrientation, true);
        }
      }else{
        window.addEventListener('pointermove', onPointerMove, {passive:true}); pointerMoveAttached=true;
      }
    }

    /* ---------- post ---------- */
    let rt = new THREE.WebGLRenderTarget(vw(),vh(),{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,depthBuffer:true});
    const screenScene=new THREE.Scene(); const screenCam=new THREE.OrthographicCamera(-1,1,1,-1,0,1);
    const fsMat=new THREE.ShaderMaterial({
      uniforms:{tDiffuse:{value:rt.texture},resolution:{value:new THREE.Vector2(vw(),vh())},pixelSize:{value:CONFIG.post.pixelSize},ditherStrength:{value:CONFIG.post.ditherStrength}},
      vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
      fragmentShader:`precision highp float;uniform sampler2D tDiffuse;uniform vec2 resolution;uniform float pixelSize;uniform float ditherStrength;varying vec2 vUv;float bayer(vec2 p){int x=int(mod(p.x,4.0));int y=int(mod(p.y,4.0));int m[16];m[0]=0;m[1]=8;m[2]=2;m[3]=10;m[4]=12;m[5]=4;m[6]=14;m[7]=6;m[8]=3;m[9]=11;m[10]=1;m[11]=9;m[12]=15;m[13]=7;m[14]=13;m[15]=5;int idx=y*4+x;return float(m[idx])/16.0;}void main(){vec2 px=vec2(max(1.0,pixelSize));vec2 uv=floor(vUv*resolution/px)*px/resolution;vec3 col=texture2D(tDiffuse,uv).rgb;float luma=dot(col,vec3(0.2126,0.7152,0.0722));vec2 grid=floor(vUv*resolution/px);float thresh=bayer(grid);float d=smoothstep(0.0,1.0,luma+(thresh-0.5)*ditherStrength);col=mix(col*0.9,col*1.1,d);gl_FragColor=vec4(col,1.0);}`
    });
    const fsQuad=new THREE.Mesh(new THREE.PlaneGeometry(2,2), fsMat); screenScene.add(fsQuad);
    function resizePost(){ rt.setSize(vw(),vh()); fsMat.uniforms.resolution.value.set(vw(),vh()); }

    /* ---------- water ---------- */
    const waterUniforms={
      uTime:{value:0},
      uCenter:{value:new THREE.Vector3(0,0,0)},
      uAmp:{value:CONFIG.water.amp},
      uFreq:{value:CONFIG.water.freq},
      uSpeed:{value:CONFIG.water.speed},
      uFalloff:{value:CONFIG.water.falloff},
      uAlpha:{value:CONFIG.water.alpha},
      uRadius:{value:CONFIG.water.radius},
      uPixel:{value:CONFIG.water.pixel},
      uColor:{value:new THREE.Color().setRGB(...CONFIG.water.tint)},
      uSpinAbs:{value:0}
    };
    const waterMat=new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      depthTest:true,
      blending:THREE.AdditiveBlending,
      uniforms:waterUniforms,
      vertexShader:`varying vec3 vWorld;varying vec2 vUv;void main(){vUv=uv;vec4 wp=modelMatrix*vec4(position,1.0);vWorld=wp.xyz;gl_Position=projectionMatrix*viewMatrix*wp;}`,
      fragmentShader:`precision highp float;varying vec3 vWorld;varying vec2 vUv;uniform vec3 uCenter;uniform float uTime,uAmp,uFreq,uSpeed,uFalloff,uAlpha,uRadius,uPixel,uSpinAbs;uniform vec3 uColor;vec2 pix(vec2 uv){float p=max(1.0,uPixel);return floor(uv*p)/p;}void main(){vec2 p=vWorld.xz-uCenter.xz;float d=length(p);float nd=clamp(d/uRadius,0.0,1.0);float w=sin(d*uFreq-(uTime*(uSpeed*(1.0+uSpinAbs*2.0))));float fall=exp(-nd*uFalloff*4.0);float h=w*uAmp*(0.5+uSpinAbs*1.4)*fall;float ring=smoothstep(0.0,1.0,abs(w));vec3 col=uColor*(0.6+1.6*h+0.5*ring);float a=clamp(uAlpha*(0.35+0.9*h+0.25*ring),0.0,1.0);vec2 uvq=pix(vUv);col*=(0.9+0.2*fract(uvq.x*128.0+uvq.y*96.0));gl_FragColor=vec4(col,a);}`
    });
    let waterMesh=new THREE.Mesh(new THREE.CircleGeometry(1,128), waterMat);
    waterMesh.rotation.x=-Math.PI/2;
    room.add(waterMesh);
    function rebuildWaterCircle(){ const r=Math.max(ROOM_W,ROOM_D)*WATER_RADIUS_FACTOR; waterMesh.geometry.dispose(); waterMesh.geometry=new THREE.CircleGeometry(r,128); }
    function resizeWater(){ waterMesh.position.set(0,-ROOM_H*0.5+0.07+CONFIG.water.yOffset,0); }
    function updateWaterCenter(){ if(!vaseReady) return; const w=new THREE.Vector3(); vaseGroup.getWorldPosition(w); const y=waterMesh.getWorldPosition(new THREE.Vector3()).y; waterUniforms.uCenter.value.set(w.x,y,w.z); }
    rebuildWaterCircle(); resizeWater();

    /* ---------- badges ---------- */
    const badgeGroup = new THREE.Group();
    scene.add(badgeGroup);
    badgeGroup.visible = false;

    let spotifyBadge=null, appleBadge=null;
    let badgesReady=false, badgesActivated=false;

    const badgesCfg = {
      sizeMul: CONFIG.badges.sizeMul,
      offsetXMul: CONFIG.badges.offsetXMul,
      yPos: (typeof CONFIG.badges.yPos === 'number' ? CONFIG.badges.yPos : 0),
      zOffset: CONFIG.badges.zOffset
    };

    function buildBadges(){
      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin('anonymous');

      const spTex = loader.load('./spotify.png', t=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.anisotropy = renderer.capabilities.getMaxAnisotropy();
        t.transparent = true;
      });
      const apTex = loader.load('./apple.png', t=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.anisotropy = renderer.capabilities.getMaxAnisotropy();
        t.transparent = true;
      });

      const geo = new THREE.PlaneGeometry(1,1);
      const makeMat = (map)=> new THREE.MeshBasicMaterial({
        map,
        transparent:true,
        alphaTest:0.02,
        depthWrite:false,
        side:THREE.DoubleSide,
        toneMapped:false
      });

      spotifyBadge = new THREE.Mesh(geo, makeMat(spTex));
      appleBadge   = new THREE.Mesh(geo, makeMat(apTex));
      spotifyBadge.renderOrder = 10;
      appleBadge.renderOrder   = 10;

      badgeGroup.add(spotifyBadge);
      badgeGroup.add(appleBadge);

      badgesReady = true;
      updateBadgesTransform();
    }

    function updateBadgesTransform(){
      if(!badgesReady || !vaseReady) return;
      const center = new THREE.Vector3();
      vaseGroup.getWorldPosition(center);

      const s = Math.min(ROOM_W, ROOM_H) * 0.12 * badgesCfg.sizeMul;
      const xOff = Math.min(ROOM_W, ROOM_D) * 0.4 * badgesCfg.offsetXMul;
      const yPos = center.y + badgesCfg.yPos;
      const zPos = center.z + badgesCfg.zOffset;

      if(spotifyBadge){
        spotifyBadge.scale.set(s, s, 1);
        spotifyBadge.position.set(center.x - xOff, yPos, zPos);
      }
      if(appleBadge){
        appleBadge.scale.set(s, s, 1);
        appleBadge.position.set(center.x + xOff, yPos, zPos);
      }
    }

    buildBadges();

    /* ---------- badge raycast ---------- */
    const raycaster=new THREE.Raycaster();
    const pointer=new THREE.Vector2();

    function handleBadgeHit(clientX, clientY){
      if(!badgesReady || !badgeGroup.visible) return false;
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((clientY - rect.top) / rect.height) * 2 + 1;
      pointer.set(x, y);
      raycaster.setFromCamera(pointer, camera);
      const objects = [spotifyBadge, appleBadge].filter(Boolean);
      const hits = raycaster.intersectObjects(objects, false);
      if(!hits.length) return false;

      const obj = hits[0].object;
      let url = null;

      if(obj === spotifyBadge) url = ALBUMS[currentAlbumKey].spotifyUrl;
      else if(obj === appleBadge) url = ALBUMS[currentAlbumKey].appleUrl;

      if(!url) return false;
      window.open(url, '_blank', 'noopener');
      return true;
    }

    renderer.domElement.addEventListener('click', (e)=>{
      handleBadgeHit(e.clientX, e.clientY);
    }, {passive:true});

    renderer.domElement.addEventListener('touchend', (e)=>{
      const t = e.changedTouches && e.changedTouches[0];
      if(!t) return;
      const handled = handleBadgeHit(t.clientX, t.clientY);
      if (handled) {
        e.preventDefault();
        e.stopPropagation();
      }
    }, {passive:false});

    /* ---------- audio (dual buffers + swap per album) ---------- */
    const A_IDLE=0.25, A_IDLE_LPF=380, A_NORM=1.0, A_NORM_LPF=18000, A_SMOOTH=0.18;

    let audioCtx=null;
    const audioBuffers = { A:null, B:null };
    let sourceNode=null, filterNode=null, gainNode=null, audioReady=false, audioStarted=false;
    let currentAudioKey = null;

    async function loadAudio(ctx, key){
      if(audioBuffers[key]) return audioBuffers[key];
      const res = await fetch(ALBUMS[key].audioUrl);
      const arr = await res.arrayBuffer();
      audioBuffers[key] = await ctx.decodeAudioData(arr);
      return audioBuffers[key];
    }

    function buildGraph(ctx){
      filterNode=ctx.createBiquadFilter();
      filterNode.type='lowpass';
      filterNode.frequency.value=A_IDLE_LPF;
      gainNode=ctx.createGain();
      gainNode.gain.value=0.9;
      filterNode.connect(gainNode).connect(ctx.destination);
    }

    function stopSource(){
      if(sourceNode){
        try{sourceNode.stop()}catch{}
        try{sourceNode.disconnect()}catch{}
        sourceNode=null;
      }
    }

    function startSource(ctx, key){
      const buf = audioBuffers[key];
      if(!buf) return;
      stopSource();
      sourceNode = ctx.createBufferSource();
      sourceNode.buffer = buf;
      sourceNode.loop = true;
      sourceNode.playbackRate.value = A_IDLE;
      sourceNode.connect(filterNode);
      sourceNode.start(ctx.currentTime+0.01);
      audioStarted = true;
      currentAudioKey = key;
      setIdleTargets();
    }

    async function initAudio(force=false){
      if(!audioCtx){
        audioCtx=new (window.AudioContext||window.webkitAudioContext)();
        buildGraph(audioCtx);
      }
      if(audioCtx.state==='suspended' && force){
        try{await audioCtx.resume()}catch{}
      }
      try{ await loadAudio(audioCtx, currentAlbumKey); }catch(e){ return; }
      if(!audioStarted){
        startSource(audioCtx, currentAlbumKey);
      }
      audioReady = true;
    }

    async function maybeStartAudio(force=false){
      if(!audioReady || (audioCtx && audioCtx.state==='suspended') || !audioStarted){
        await initAudio(force);
      }
    }

    async function switchAudioTo(key){
      if(!audioCtx || !audioStarted) return;
      if(currentAudioKey === key) return;
      try{
        await loadAudio(audioCtx, key);
      }catch(e){
        return;
      }
      startSource(audioCtx, key);
      updateAudio(Math.abs(angVel));
    }

    function setIdleTargets(){
      if(!audioCtx||!filterNode||!sourceNode) return;
      const t=audioCtx.currentTime+0.01;
      filterNode.frequency.setTargetAtTime(A_IDLE_LPF,t,A_SMOOTH);
      sourceNode.playbackRate.setTargetAtTime(A_IDLE,t,A_SMOOTH);
    }

    function ease(t){ return t*t*(3-2*t); }

    function updateAudio(speed){
      if(!audioReady||!sourceNode||!filterNode) return;
      const k=ease(THREE.MathUtils.clamp(speed/Math.max(0.001,FULL_SPIN),0,1));
      const rate=THREE.MathUtils.lerp(A_IDLE,A_NORM,k);
      const lpf=THREE.MathUtils.lerp(A_IDLE_LPF,A_NORM_LPF,k);
      const t=audioCtx.currentTime+0.01;
      sourceNode.playbackRate.setTargetAtTime(rate,t,A_SMOOTH);
      filterNode.frequency.setTargetAtTime(lpf,t,A_SMOOTH);
    }

    window.addEventListener('load',()=>{initAudio(false)},{once:true});
    window.addEventListener('pointerdown',()=>{maybeStartAudio(true)},{once:true});

    /* ---------- header opacity from spin ---------- */
    function updateHeaderOpacity(speed){
      if(!headerMat || headerOpacityLocked) return;
      const t = THREE.MathUtils.clamp(speed/Math.max(0.001,FULL_SPIN),0,1);
      const k = ease(t);
      const op = HEADER_OPACITY_MAX * (1.0 - Math.exp(-4.0*k));
      headerMat.opacity = op;
      if(k>=0.999){ headerMat.opacity=HEADER_OPACITY_MAX; headerOpacityLocked=true; }
    }

    /* ---------- main loop ---------- */
    const clock=new THREE.Clock(); const tmpV3=new THREE.Vector3();
    function animate(){
      requestAnimationFrame(animate);
      const dt=Math.min(clock.getDelta(),0.033); const time=clock.elapsedTime;

      updateVase(dt,time);

      const speedAbs=Math.abs(angVel);
      if(wallShader){
        const dir=(angVel>=0?1:-1);
        wallShader.uniforms.uTime.value += dt * dir * (1.0 + Math.min(3.0, speedAbs*2.4));
      }

      if(!badgesActivated && speedAbs>=FULL_SPIN){
        badgesActivated=true;
        if(badgesReady) badgeGroup.visible=true;
      }

      updateAudio(speedAbs);
      updateHeaderOpacity(speedAbs);

      cubeCam.position.copy(vaseGroup.getWorldPosition(tmpV3));
      const headerWasVisible = headerGroup.visible;
      const vaseWasVisible = vaseGroup.visible;
      if(vaseReady && vase) vase.visible = false;
      headerGroup.visible = false;
      cubeCam.update(renderer, scene);
      if(vaseReady && vase) vase.visible = true;
      headerGroup.visible = headerWasVisible;
      vaseGroup.visible = vaseWasVisible;

      room.rotation.x += (targetRX - room.rotation.x)*0.06;
      room.rotation.y += (targetRY - room.rotation.y)*0.06;
      edges.rotation.copy(room.rotation);
      badgeGroup.rotation.copy(room.rotation);

      if(headerMesh){ headerGroup.lookAt(camera.position); }

      updateWaterCenter();
      waterUniforms.uTime.value=time;
      waterUniforms.uSpinAbs.value=speedAbs;
      updateBadgesTransform();

      const usePost = (CONFIG.post.pixelSize>1)||(CONFIG.post.ditherStrength>0.0001);
      if(usePost){
        renderer.setRenderTarget(rt);
        renderer.render(scene,camera);
        renderer.setRenderTarget(null);
        renderer.render(screenScene,screenCam);
      } else {
        renderer.render(scene,camera);
      }
    }
    animate();

    /* ---------- layout / resize ---------- */
    function updateLayout(){
      renderer.setSize(vw(),vh(),false);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, isPhone()?1.5:1.8));
      renderer.toneMappingExposure = CONFIG.lights.exposure;
      key.position.set(1.5,-ROOM_H*0.1, room.position.z + ROOM_D*0.05);
      resizePost(); applyVaseScale(); resizeWater(); adjustRoomToViewport(); updateBadgesTransform();
      badgeGroup.rotation.copy(room.rotation);
      applyTextureZoom(currentWallTex, zoomCurrent);
    }
    window.addEventListener('resize',updateLayout,{passive:true});
    window.addEventListener('orientationchange',updateLayout,{passive:true});
    if(window.visualViewport) window.visualViewport.addEventListener('resize',updateLayout,{passive:true});

    renderer.domElement.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
    renderer.domElement.addEventListener('wheel', e=>e.preventDefault(), {passive:false});

    setupInput();
    updateLayout();

    // apply initial album state
    setAlbum(currentAlbumKey, {force:true});

    /* ---------- UI + bindings ---------- */
    const panel=document.getElementById('panel'); const toggle=document.getElementById('toggleControls'); const $=id=>document.getElementById(id);
    function togglePanel(){ panel.style.display = (panel.style.display==='block') ? 'none' : 'block'; }
    if (toggle) toggle.addEventListener('click',togglePanel);
    window.addEventListener('keydown',e=>{ if(e.key.toLowerCase()==='h') togglePanel(); });

    document.getElementById('tabs').addEventListener('click', e=>{
      const btn=e.target.closest('.tab-btn'); if(!btn) return;
      for(const b of e.currentTarget.querySelectorAll('.tab-btn')) b.classList.toggle('active', b===btn);
      for(const pg of document.querySelectorAll('.tabpage')) pg.classList.toggle('active', pg.id===btn.dataset.tab);
    });

    function setVal(id,v){ const el=$(id); if(el) el.value=v; }
    function bindRange(numId, rangeId, getVal, setValFn){
      const num=$(numId), range=$(rangeId); const init=getVal(); num.value=init; range.value=init;
      const sync=v=>{ const val=+v; num.value=val; range.value=val; setValFn(val); };
      num.addEventListener('change', e=>sync(e.target.value)); range.addEventListener('input', e=>sync(e.target.value));
    }

    function syncVasePositionInputs(){ $('vaseZ').value=$('vaseZNum').value=vaseGroup.position.z; $('vaseYPos').value=$('vaseYPosNum').value=vaseGroup.position.y; }

    // Vase
    bindRange('vaseNum','vase', ()=>CONFIG.vase.userScaleMult, v=>{CONFIG.vase.userScaleMult=v; userScaleMult=v; applyVaseScale();});
    bindRange('vaseYNum','vaseY', ()=>CONFIG.vase.userTallY, v=>{CONFIG.vase.userTallY=v; userTallY=v; applyVaseScale();});
    bindRange('vaseZNum','vaseZ', ()=>CONFIG.vase.z, v=>{CONFIG.vase.z=v; vaseGroup.position.z=v; updateBadgesTransform(); syncVasePositionInputs();});
    bindRange('vaseYPosNum','vaseYPos', ()=>CONFIG.vase.y, v=>{CONFIG.vase.y=v; vaseGroup.position.y=v; updateBadgesTransform(); syncVasePositionInputs();});

    // Spin
    bindRange('dampNum','damp', ()=>CONFIG.spin.damping, v=>{CONFIG.spin.damping=v; DAMPING=v;});
    bindRange('minNum','min', ()=>CONFIG.spin.minSpin, v=>{CONFIG.spin.minSpin=v; MIN_SPIN=v;});
    bindRange('impNum','imp', ()=>CONFIG.spin.swipeImpulse, v=>{CONFIG.spin.swipeImpulse=v; IMPULSE=v;});

    // Room
    bindRange('dNum','d', ()=>ROOM_D, v=>{ROOM_D=v; adjustRoomToViewport();});
    bindRange('zNum','z', ()=>room.position.z, v=>{room.position.z=v; edges.position.copy(room.position); adjustRoomToViewport();});
    bindRange('zoomNum','zoom', ()=>zoomCurrent, v=>{
      zoomBase = v;
      applyZoom(v);
    });
    bindRange('edgeNum','edge', ()=>edges.material.opacity, v=>{edges.material.opacity=Math.max(0,Math.min(1,v)); edges.material.needsUpdate=true;});

    // Lights
    bindRange('expNum','exp', ()=>CONFIG.lights.exposure, v=>{CONFIG.lights.exposure=v; renderer.toneMappingExposure=v;});
    bindRange('ambNum','amb', ()=>CONFIG.lights.ambient, v=>{CONFIG.lights.ambient=v; amb.intensity=v;});
    bindRange('hemNum','hem', ()=>CONFIG.lights.hemisphere, v=>{CONFIG.lights.hemisphere=v; hemi.intensity=v;});
    bindRange('rimNum','rim', ()=>CONFIG.lights.rim, v=>{CONFIG.lights.rim=v; rim.intensity=v;});
    bindRange('keyNum','key', ()=>CONFIG.lights.key, v=>{CONFIG.lights.key=v; key.intensity=v;});
    bindRange('vlINum','vlI', ()=>CONFIG.lights.vaseLight.intensity, v=>{CONFIG.lights.vaseLight.intensity=v; vaseLight.intensity=v;});
    bindRange('vlDNum','vlD', ()=>CONFIG.lights.vaseLight.distance, v=>{CONFIG.lights.vaseLight.distance=v; vaseLight.distance=v;});
    bindRange('vlDecNum','vlDec', ()=>CONFIG.lights.vaseLight.decay, v=>{CONFIG.lights.vaseLight.decay=v; vaseLight.decay=v;});
    bindRange('vlYNum','vlY', ()=>CONFIG.lights.vaseLight.y, v=>{CONFIG.lights.vaseLight.y=v; vaseLight.position.y=v;});

    // Water
    bindRange('wAmpNum','wAmp', ()=>CONFIG.water.amp, v=>{CONFIG.water.amp=v; waterUniforms.uAmp.value=v;});
    bindRange('wFreqNum','wFreq', ()=>CONFIG.water.freq, v=>{CONFIG.water.freq=v; waterUniforms.uFreq.value=v;});
    bindRange('wSpeedNum','wSpeed', ()=>CONFIG.water.speed, v=>{CONFIG.water.speed=v; waterUniforms.uSpeed.value=v;});
    bindRange('wFallNum','wFall', ()=>CONFIG.water.falloff, v=>{CONFIG.water.falloff=v; waterUniforms.uFalloff.value=v;});
    bindRange('wAlphaNum','wAlpha', ()=>CONFIG.water.alpha, v=>{CONFIG.water.alpha=v; waterUniforms.uAlpha.value=v;});
    bindRange('wRadNum','wRad', ()=>CONFIG.water.radius, v=>{CONFIG.water.radius=v; rebuildWaterCircle();});
    bindRange('wPixNum','wPix', ()=>CONFIG.water.pixel, v=>{CONFIG.water.pixel=v|0; waterUniforms.uPixel.value=v|0;});
    bindRange('wYNum','wY', ()=>CONFIG.water.yOffset, v=>{CONFIG.water.yOffset=v; resizeWater();});

    // Glass
    function applyGlass(){
      for(const m of glassMaterials){
        m.transmission=CONFIG.glass.transmission; m.thickness=CONFIG.glass.thickness; m.ior=CONFIG.glass.ior;
        m.roughness=CONFIG.glass.roughness; m.clearcoat=CONFIG.glass.clearcoat; m.clearcoatRoughness=CONFIG.glass.ccRough;
        m.envMapIntensity=CONFIG.glass.envIntensity; m.metalness=CONFIG.glass.metalness;
        m.color.setRGB(...CONFIG.glass.color); m.attenuationColor.setRGB(...CONFIG.glass.attnColor); m.envMap=cubeRT.texture; m.needsUpdate=true;
      }
    }
    bindRange('glassTransNum','glassTrans', ()=>CONFIG.glass.transmission, v=>{CONFIG.glass.transmission=v; applyGlass();});
    bindRange('glassThickNum','glassThick', ()=>CONFIG.glass.thickness, v=>{CONFIG.glass.thickness=v; applyGlass();});
    bindRange('glassIorNum','glassIor', ()=>CONFIG.glass.ior, v=>{CONFIG.glass.ior=v; applyGlass();});
    bindRange('glassRoughNum','glassRough', ()=>CONFIG.glass.roughness, v=>{CONFIG.glass.roughness=v; applyGlass();});
    bindRange('glassCCNum','glassCC', ()=>CONFIG.glass.clearcoat, v=>{CONFIG.glass.clearcoat=v; applyGlass();});
    bindRange('glassCCRNum','glassCCR', ()=>CONFIG.glass.ccRough, v=>{CONFIG.glass.ccRough=v; applyGlass();});
    bindRange('glassEnvNum','glassEnv', ()=>CONFIG.glass.envIntensity, v=>{CONFIG.glass.envIntensity=v; applyGlass();});
    bindRange('glassMetalNum','glassMetal', ()=>CONFIG.glass.metalness, v=>{CONFIG.glass.metalness=v; applyGlass();});

    // Header + badges UI
    function bindHeaderUI(){
      const upd=()=>{ if(headerMat) headerMat.needsUpdate=true; };
      bindRange('hdrSizeNum','hdrSize', ()=>headerCfg.sizeMul, v=>{headerCfg.sizeMul=Math.max(0.2,Math.min(3,v)); rebuildHeaderGeometry();});
      bindRange('hdrXNum','hdrX', ()=>headerCfg.x, v=>{headerCfg.x=v; applyHeaderTransform();});
      bindRange('hdrYNum','hdrY', ()=>headerCfg.y, v=>{headerCfg.y=v; applyHeaderTransform();});
      bindRange('hdrZNum','hdrZ', ()=>headerCfg.z, v=>{headerCfg.z=v; applyHeaderTransform();});
      bindRange('hdrMetalNum','hdrMetal', ()=>headerCfg.metalness, v=>{headerCfg.metalness=v; if(headerMat){headerMat.metalness=v; upd();}});
      bindRange('hdrRoughNum','hdrRough', ()=>headerCfg.roughness, v=>{headerCfg.roughness=v; if(headerMat){headerMat.roughness=v; upd();}});
      bindRange('hdrCCNum','hdrCC', ()=>headerCfg.clearcoat, v=>{headerCfg.clearcoat=v; if(headerMat){headerMat.clearcoat=v; upd();}});
      bindRange('hdrCCRNum','hdrCCR', ()=>headerCfg.clearcoatRoughness, v=>{headerCfg.clearcoatRoughness=v; if(headerMat){headerMat.clearcoatRoughness=v; upd();}});
      bindRange('hdrEnvNum','hdrEnv', ()=>headerCfg.envIntensity, v=>{headerCfg.envIntensity=v; if(headerMat){headerMat.envMapIntensity=v; upd();}});
      bindRange('hdrTransNum','hdrTrans', ()=>headerCfg.transmission, v=>{headerCfg.transmission=v; if(headerMat){headerMat.transmission=v; upd();}});
      bindRange('hdrThickNum','hdrThick', ()=>headerCfg.thickness, v=>{headerCfg.thickness=v; if(headerMat){headerMat.thickness=v; upd();} rebuildHeaderGeometry();});
      bindRange('hdrEmissNum','hdrEmiss', ()=>headerCfg.emissiveIntensity, v=>{headerCfg.emissiveIntensity=v; if(headerMat){headerMat.emissiveIntensity=v; upd();}});

      const badgesCfgLocal = badgesCfg;
      bindRange('bdgSizeNum','bdgSize', ()=>badgesCfgLocal.sizeMul, v=>{
        badgesCfgLocal.sizeMul = Math.max(0.3, Math.min(3,v));
        updateBadgesTransform();
      });
      bindRange('bdgXOffNum','bdgXOff', ()=>badgesCfgLocal.offsetXMul, v=>{
        badgesCfgLocal.offsetXMul = Math.max(0, Math.min(2,v));
        updateBadgesTransform();
      });
      bindRange('bdgYPosNum','bdgYPos', ()=>badgesCfgLocal.yPos, v=>{
        badgesCfgLocal.yPos = v;
        updateBadgesTransform();
      });
      bindRange('bdgZOffNum','bdgZOff', ()=>badgesCfgLocal.zOffset, v=>{
        badgesCfgLocal.zOffset = v;
        updateBadgesTransform();
      });
    }
    bindHeaderUI();

    // Post
    bindRange('pixNum','pix', ()=>CONFIG.post.pixelSize, v=>{CONFIG.post.pixelSize=v; fsMat.uniforms.pixelSize.value=v;});
    bindRange('dithNum','dith', ()=>CONFIG.post.ditherStrength, v=>{CONFIG.post.ditherStrength=v; fsMat.uniforms.ditherStrength.value=v;});

    // Init UI
    function initUI(){
      const set=(id,v)=>{ setVal(id,v); setVal(id+'Num',v); };
      set('vase',CONFIG.vase.userScaleMult); set('vaseY',CONFIG.vase.userTallY); set('vaseZ',CONFIG.vase.z); set('vaseYPos',CONFIG.vase.y);
      set('damp',CONFIG.spin.damping); set('min',CONFIG.spin.minSpin); set('imp',CONFIG.spin.swipeImpulse);
      set('d',ROOM_D); set('z',room.position.z); set('zoom',CONFIG.room.imageZoom); set('edge',CONFIG.room.borderOpacity);
      set('exp',CONFIG.lights.exposure); set('amb',CONFIG.lights.ambient); set('hem',CONFIG.lights.hemisphere); set('rim',CONFIG.lights.rim); set('key',CONFIG.lights.key);
      set('vlI',CONFIG.lights.vaseLight.intensity); set('vlD',CONFIG.lights.vaseLight.distance); set('vlDec',CONFIG.lights.vaseLight.decay); set('vlY',CONFIG.lights.vaseLight.y);
      set('wAmp',CONFIG.water.amp); set('wFreq',CONFIG.water.freq); set('wSpeed',CONFIG.water.speed); set('wFall',CONFIG.water.falloff); set('wAlpha',CONFIG.water.alpha); set('wRad',CONFIG.water.radius); set('wPix',CONFIG.water.pixel); set('wY',CONFIG.water.yOffset);
      set('glassTrans',CONFIG.glass.transmission); set('glassThick',CONFIG.glass.thickness); set('glassIor',CONFIG.glass.ior); set('glassRough',CONFIG.glass.roughness); set('glassCC',CONFIG.glass.clearcoat); set('glassCCR',CONFIG.glass.ccRough); set('glassEnv',CONFIG.glass.envIntensity); set('glassMetal',CONFIG.glass.metalness);
      set('hdrSize',headerCfg.sizeMul); set('hdrX',headerCfg.x); set('hdrY',headerCfg.y); set('hdrZ',headerCfg.z); set('hdrMetal',headerCfg.metalness); set('hdrRough',headerCfg.roughness); set('hdrCC',headerCfg.clearcoat); set('hdrCCR',headerCfg.clearcoatRoughness); set('hdrEnv',headerCfg.envIntensity); set('hdrTrans',headerCfg.transmission); set('hdrThick',headerCfg.thickness); set('hdrEmiss',headerCfg.emissiveIntensity);
      set('bdgSize',badgesCfg.sizeMul); set('bdgXOff',badgesCfg.offsetXMul); set('bdgYPos',badgesCfg.yPos); set('bdgZOff',badgesCfg.zOffset);
      set('pix',CONFIG.post.pixelSize); set('dith',CONFIG.post.ditherStrength);
    }
    initUI();

    function snapshot(){
      const snap=structuredClone(CONFIG);
      snap.room.width=ROOM_W; snap.room.height=ROOM_H; snap.room.depth=ROOM_D; snap.room.positionZ=room.position.z;
      snap.vase.z=vaseGroup.position.z; snap.vase.y=vaseGroup.position.y;
      snap._internal={WATER_RADIUS_FACTOR,TILT_MARGIN}; snap._preset=presetChoice;
      snap._album=currentAlbumKey;
      snap._zoomTerminals = getZoomTerminals();
      snap.header={
        opacity:headerMat?headerMat.opacity:0,
        sizeMul:headerCfg.sizeMul,
        x:headerCfg.x,y:headerCfg.y,z:headerCfg.z,
        locked:headerOpacityLocked,
        metalness:headerCfg.metalness,
        roughness:headerCfg.roughness,
        clearcoat:headerCfg.clearcoat,
        clearcoatRoughness:headerCfg.clearcoatRoughness,
        envIntensity:headerCfg.envIntensity,
        transmission:headerCfg.transmission,
        thickness:headerCfg.thickness,
        emissiveIntensity:headerCfg.emissiveIntensity
      };
      snap.badges = {
        sizeMul:badgesCfg.sizeMul,
        offsetXMul:badgesCfg.offsetXMul,
        yPos:badgesCfg.yPos,
        zOffset:badgesCfg.zOffset,
        activated:badgesActivated
      };
      return snap;
    }

    window.addEventListener('keydown',e=>{ if(e.key.toLowerCase()==='p') console.log(JSON.stringify(snapshot(),null,2)); });
    $('printControlsBtn').onclick=()=>console.log(JSON.stringify(snapshot(),null,2));
    $('copyControlsBtn').onclick=async()=>{const text=JSON.stringify(snapshot(),null,2); try{await navigator.clipboard.writeText(text);}catch{}};
  </script>
</body>
</html>
